"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7672],{2271:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>d,default:()=>l,frontMatter:()=>c,metadata:()=>n,toc:()=>r});const n=JSON.parse('{"id":"eventsub/conduit","title":"Conduit","description":"Conduits are a wrapper transport type that simplify forward EventSub notifications to other transports.","source":"@site/versioned_docs/version-1.x/eventsub/conduit.mdx","sourceDirName":"eventsub","slug":"/eventsub/conduit","permalink":"/eventsub/conduit","draft":false,"unlisted":false,"editUrl":"https://github.com/twitch4j/twitch4j.github.io/tree/master/docs/versioned_docs/version-1.x/eventsub/conduit.mdx","tags":[],"version":"1.x","lastUpdatedBy":"iProdigy","lastUpdatedAt":1721173267000,"frontMatter":{},"sidebar":"version-1.x-docs","previous":{"title":"EventSub","permalink":"/eventsub/"},"next":{"title":"Webhook","permalink":"/eventsub/webhook"}}');var s=i(4848),o=i(8453);const c={},d="Conduit",a={},r=[{value:"Library-managed websocket pool",id:"library-managed-websocket-pool",level:2},{value:"Single Client",id:"single-client",level:3},{value:"Distributed Clients",id:"distributed-clients",level:3},{value:"Manual conduit management",id:"manual-conduit-management",level:2},{value:"Adding webhook shards",id:"adding-webhook-shards",level:3},{value:"Decreasing the shard count on an existing conduit",id:"decreasing-the-shard-count-on-an-existing-conduit",level:3},{value:"Single Client",id:"single-client-1",level:4},{value:"Distributed Clients",id:"distributed-clients-1",level:4}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"conduit",children:"Conduit"})}),"\n",(0,s.jsx)(t.p,{children:"Conduits are a wrapper transport type that simplify forward EventSub notifications to other transports."}),"\n",(0,s.jsxs)(t.p,{children:["Conduits are intended for server-side applications, and utilize ",(0,s.jsx)(t.strong,{children:"app"})," access tokens to manage EventSub subscriptions."]}),"\n",(0,s.jsx)(t.p,{children:"A conduit is comprised of shards, which can be webhooks or websockets."}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsx)(t.p,{children:"Conduits are typically utilized by backends where webhooks are not feasible (e.g., due to firewall restrictions).\nThus, the server can receive EventSub notifications via websockets (that are associated with a conduit)."})}),"\n",(0,s.jsx)(t.p,{children:"A conduit can be associated with many EventSub subscriptions (often spanning multiple users).\nWhen an EventSub notification is triggered, Twitch decides which of the conduit shards will receive the notification (as if Twitch were handling load balancing for you).\nIf the target shard did not receive the notification, Twitch will retry with one other shard."}),"\n",(0,s.jsxs)(t.admonition,{type:"note",children:[(0,s.jsx)(t.p,{children:"Conduits can also easily be scaled up with additional shards. Scaling down is also possible, but more tedious."}),(0,s.jsx)(t.p,{children:"Clients are limited to 5 enabled conduits, with up to 20,000 shards per conduit."})]}),"\n",(0,s.jsx)(t.p,{children:"Conduits can be more resilient than plain webhooks or websockets.\nIf a standard websocket momentarily disconnects, all of the EventSub subscriptions must be recreated.\nIf a standard webhook doesn't acknowledge a notification across Twitch's multiple attempts (typically 5 within a few minutes), the EventSub subscription is disabled.\nWhen the websocket or webhook is associated with a conduit, these failures only disable the shard.\nWith conduits, all of the shards must be disabled for 72 hours before Twitch deletes the conduit."}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsx)(t.p,{children:"Avoid having more than one disabled websocket shard at a time, as EventSub notifications could be dropped by Twitch."}),(0,s.jsx)(t.p,{children:"If webhook shards are used, Twitch will retry notifications for the given webhook, but will not retry across multiple shards."}),(0,s.jsxs)(t.p,{children:["You can utilize the ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/subscriptions/ConduitShardDisabledType.html",children:(0,s.jsx)(t.code,{children:"conduit.shard.disabled"})})," topic to track when shards are disabled."]}),(0,s.jsx)(t.p,{children:"If you are using a Conduit backed by websockets on a single server, you can generally ignore this detail."})]}),"\n",(0,s.jsxs)(t.p,{children:["The subscription cost model is the same as normal webhooks; users simply authorize to your Client ID with the appropriate scopes, so you can create zero cost subscriptions.\nThe default ",(0,s.jsx)(t.code,{children:"max_total_cost"})," is still 10,000."]}),"\n",(0,s.jsxs)(t.p,{children:["For more information, please consult the ",(0,s.jsx)(t.a,{href:"https://dev.twitch.tv/docs/eventsub/handling-conduit-events/",children:"official documentation"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"library-managed-websocket-pool",children:"Library-managed websocket pool"}),"\n",(0,s.jsxs)(t.p,{children:["For the common use case of websocket-backed conduits, the library offers ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/socket/conduit/TwitchConduitSocketPool.html",children:(0,s.jsx)(t.code,{children:"TwitchConduitSocketPool"})}),", which simplifies shard and subscription management."]}),"\n",(0,s.jsx)(t.h3,{id:"single-client",children:"Single Client"}),"\n",(0,s.jsxs)(t.p,{children:["If your application runs on a single server, you only need one ",(0,s.jsx)(t.code,{children:"TwitchConduitSocketPool"})," instance."]}),"\n",(0,s.jsxs)(t.p,{children:["Simply decide how many websocket shards you would like created (",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/socket/conduit/ConduitSpec.html#poolShards(int)",children:(0,s.jsx)(t.code,{children:"ConduitSpec#poolShards(int)"})}),") and provide client authorization (i.e., an app access token or both the client id/secret)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'IEventSubConduit conduit = TwitchConduitSocketPool.create(spec -> {\n    spec.clientId("your-client-id");\n    spec.clientSecret("your-client-secret");\n    spec.poolShards(4); // customizable pool size\n});\nconduit.register(SubscriptionTypes.STREAM_ONLINE, b -> b.broadcasterUserId("926829122").build());\nconduit.getEventManager().onEvent(StreamOnlineEvent.class, System.out::println);\n'})}),"\n",(0,s.jsx)(t.p,{children:"Under the hood, Twitch4J will create a new conduit, spawn each websocket, associate each websocket to the conduit, register the requested subscriptions to the conduit, and fire events as the conduit receives EventSub notifications."}),"\n",(0,s.jsxs)(t.p,{children:["You can utilize ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/socket/conduit/TwitchConduitSocketPool.html#getConduitId()",children:(0,s.jsx)(t.code,{children:"TwitchConduitSocketPool#getConduitId"})})," to obtain the conduit ID associated with the pool."]}),"\n",(0,s.jsxs)(t.p,{children:["Once a pool has been created, you can utilize ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/socket/conduit/ConduitSpec.html#conduitId(java.lang.String)",children:(0,s.jsx)(t.code,{children:"ConduitSpec#conduitId(String)"})})," to reuse the same conduit, which can be useful when restarting your bot (e.g., to avoid recreating every EventSub subscription)."]}),"\n",(0,s.jsx)(t.h3,{id:"distributed-clients",children:"Distributed Clients"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"TwitchConduitSocketPool"})," can also be used to subscribe to a single conduit across multiple servers."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, a conduit could be created with 12 total shards, and shared across 3 servers.\nThen, each server can create a ",(0,s.jsx)(t.code,{children:"TwitchConduitSocketPool"})," instance with 4 pool shards each, all associated to the same conduit ID.\nThe first server would cover shards with indices 0, 1, 2, 3, so the ",(0,s.jsx)(t.a,{href:"(https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/socket/conduit/ConduitSpec.html#shardOffset(int))",children:"shard offset"})," should be 0.\nThe second server would cover shards 4, 5, 6, 7, so the shard offset should be 4.\nThe third server would cover shards 8, 9, 10, 11, so the shard offset should be 8."]}),"\n",(0,s.jsx)(t.p,{children:"First server:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'IEventSubConduit conduit = TwitchConduitSocketPool.create(spec -> {\n    // spec.conduitId("the-conduit-id"); // specify the Conduit ID if it has already been created\n    spec.clientId("your-client-id");\n    spec.clientSecret("your-client-secret");\n    spec.poolShards(4);\n    spec.totalShardCount(12);\n    spec.shardOffset(0);\n});\nconduit.getEventManager().onEvent(StreamOnlineEvent.class, System.out::println);\n'})}),"\n",(0,s.jsx)(t.p,{children:"Second server:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'IEventSubConduit conduit = TwitchConduitSocketPool.create(spec -> {\n    spec.conduitId("the-conduit-id");\n    spec.clientId("your-client-id");\n    spec.clientSecret("your-client-secret");\n    spec.poolShards(4);\n    spec.totalShardCount(12);\n    spec.shardOffset(4);\n});\nconduit.getEventManager().onEvent(StreamOnlineEvent.class, System.out::println);\n'})}),"\n",(0,s.jsx)(t.p,{children:"Third server:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-java",children:'IEventSubConduit conduit = TwitchConduitSocketPool.create(spec -> {\n    spec.conduitId("the-conduit-id");\n    spec.clientId("your-client-id");\n    spec.clientSecret("your-client-secret");\n    spec.poolShards(4);\n    spec.totalShardCount(12);\n    spec.shardOffset(8);\n});\nconduit.getEventManager().onEvent(StreamOnlineEvent.class, System.out::println);\n'})}),"\n",(0,s.jsx)(t.p,{children:"With the distributed approach, only one client needs to register the EventSub subscriptions, and events will be distributed across the various websockets by Twitch."}),"\n",(0,s.jsx)(t.h2,{id:"manual-conduit-management",children:"Manual conduit management"}),"\n",(0,s.jsx)(t.p,{children:"For certain uncommon use cases, you may have to directly call the Helix API to manage the Conduit.\nFeel free to join our Discord (linked in the header) if you have any questions."}),"\n",(0,s.jsx)(t.h3,{id:"adding-webhook-shards",children:"Adding webhook shards"}),"\n",(0,s.jsxs)(t.p,{children:["While ",(0,s.jsx)(t.code,{children:"TwitchConduitSocketPool"})," only registers websockets, you ",(0,s.jsx)(t.em,{children:"could"})," add webhook shards manually.\nTypically, this is only relevant for distributed clients where some servers cannot use webhooks while others can;\nmost commonly people use exclusively webhooks or exclusively websockets across their shards rather than a hybrid of both."]}),"\n",(0,s.jsxs)(t.p,{children:["First, you need to increase the shard count for the conduit via ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/helix/TwitchHelix.html#updateConduit(java.lang.String,java.lang.String,int)",children:(0,s.jsx)(t.code,{children:"TwitchHelix#updateConduit"})}),".\nTo obtain the current shard count, you can call ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/helix/TwitchHelix.html#getConduits(java.lang.String)",children:(0,s.jsx)(t.code,{children:"TwitchHelix#getConduits"})}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Then, you can call ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/helix/TwitchHelix.html#updateConduitShards(java.lang.String,com.github.twitch4j.helix.domain.ShardsInput)",children:(0,s.jsx)(t.code,{children:"TwitchHelix#updateConduitShards"})}),"\nto register the new webhook shards at the specific shard indices that were just created."]}),"\n",(0,s.jsx)(t.admonition,{type:"note",children:(0,s.jsx)(t.p,{children:"Shard IDs are numeric strings that are zero-indexed."})}),"\n",(0,s.jsxs)(t.p,{children:["Finally, you still will need to spin up a HTTPS webhook server as described ",(0,s.jsx)(t.a,{href:"./webhook",children:"here"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"decreasing-the-shard-count-on-an-existing-conduit",children:"Decreasing the shard count on an existing conduit"}),"\n",(0,s.jsx)(t.h4,{id:"single-client-1",children:"Single Client"}),"\n",(0,s.jsxs)(t.p,{children:["To reduce the number of shards used for the single ",(0,s.jsx)(t.code,{children:"TwitchConduitSocketPool"})," use case:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Specify the reduced shard count in ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/socket/conduit/ConduitSpec.html#poolShards(int)",children:(0,s.jsx)(t.code,{children:"ConduitSpec#poolShards(int)"})})," (and restart the client)."]}),"\n",(0,s.jsxs)(t.li,{children:["Reflect the reduced shard count in the Helix API via ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/helix/TwitchHelix.html#updateConduit(java.lang.String,java.lang.String,int)",children:(0,s.jsx)(t.code,{children:"TwitchHelix#updateConduit"})}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"distributed-clients-1",children:"Distributed Clients"}),"\n",(0,s.jsx)(t.p,{children:"For distributed clients, one typically only deletes shards if they are taking down a client for an extended period of time."}),"\n",(0,s.jsxs)(t.p,{children:["If the shard IDs to be deleted are the last shards (i.e., highest IDs), you can simply call ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/helix/TwitchHelix.html#updateConduit(java.lang.String,java.lang.String,int)",children:(0,s.jsx)(t.code,{children:"TwitchHelix#updateConduit"})})," with the desired shard count."]}),"\n",(0,s.jsxs)(t.p,{children:["Otherwise, you need to call ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/helix/TwitchHelix.html#updateConduitShards(java.lang.String,com.github.twitch4j.helix.domain.ShardsInput)",children:(0,s.jsx)(t.code,{children:"TwitchHelix#updateConduitShards"})})," to shift existing shards to overwrite the shards to be deleted.\nThen you can call ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/helix/TwitchHelix.html#updateConduit(java.lang.String,java.lang.String,int)",children:(0,s.jsx)(t.code,{children:"TwitchHelix#updateConduit"})})," with the reduced shard count."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, if a conduit has 10 shards, the IDs will be 0 through 9.\nIf we want to remove the second and third shards, we can simply overwrite the id=1 and id=2 shards with the last two shards (i.e., id=8 and i=9) in the Helix API, which works because multiple shards can share the same transport.\nThen we can reduce the overall shard count of the conduit in the Helix API.\nIdeally you should restart the websocket clients that managed the last two shards with the updated ",(0,s.jsx)(t.a,{href:"https://twitch4j.github.io/javadoc/com/github/twitch4j/eventsub/socket/conduit/ConduitSpec.html#shardOffset(int)",children:(0,s.jsx)(t.code,{children:"ConduitSpec#shardOffset"})}),"."]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>c,x:()=>d});var n=i(6540);const s={},o=n.createContext(s);function c(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);